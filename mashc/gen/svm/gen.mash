uses <classes\stringlist>
uses "gen\svm\gen_types.mash"

/*
 *  Code generation for SVM
 */

class GeneratorSVM:
  protected:
    var Sem, Out,
        GCN,  // Generated construction number

        LazyGen,
        LazyGenSwap,

        ExprBeginnings

  public:
    proc Create
    func Gen

  private:
    proc ProcessNext,
         NextNode,
         LazyGenCode

    proc GenHeader
    func GenOperation

    func LastExprFlag
    proc LastExprFlagChange

    func GenMethodHeader
    proc GenMethodEnd,
         GenArrayOp,
         GenArrayAlloc
end

proc GeneratorSVM::Create():
  $GCN ?= 0
  $Out ?= new StringList()
  $LazyGen ?= new list()
  $LazyGenSwap ?= new list()

  $ExprBeginnings ?= new vector() // flags stack for correctly var pushing/peeking
end

func GeneratorSVM::Gen(Sem):
  $Sem ?= Sem

  for imp in Sem -> Impl -> items:
    $Out -> Add("import " + imp -> method_name + " " +
                DQuote + imp -> lib + DQuote + " " +
                DQuote + imp -> name + DQuote)
    gc()
  end

  $GenHeader()

  for g in Sem -> Global -> items:
    $ProcessNext(g, null, "")
    gc()
  end

  for m in Sem -> Methods -> items:
    mname ?= $GenMethodHeader(m)
    $ProcessNext(m, m -> varlist, mname)
    $GenMethodEnd(m, mname)
    gc()
  end

  return $Out
end

proc GeneratorSVM::LazyGenCode(code):
  $LazyGen -> Add( new PreGenerated(code) )
end

/*
 *  Generating headers or something like this
 */
proc GeneratorSVM::GenHeader():
  for ct in $Sem -> const_lst -> items:
    if ct -> isStream:
      $Out -> Add("stream " + ct -> Name + " " + DQuote + ct -> Value + DQuote)
    else:
      if ct -> info == ttString:
        $Out -> Add("str " + ct -> Name + " " + DQuote + ct -> Value + DQuote)
      else:
        if "." in ct -> value:
          $Out -> Add("real " + ct -> Name + " " + ct -> Value)
        else:
          if "-" in ct -> value:
            $Out -> Add("int " + ct -> Name + " " + ct -> Value)
          else:
            $Out -> Add("word " + ct -> Name + " " + ct -> Value)
          end
        end
      end
    end
  end

  $Out -> Add("@global.arg_counter")
  $Out -> Add("@global.temp")

  $Out -> Add("word generator.const.gcn." + $gcn + " 0")
  $Out -> Add("pushc generator.const.gcn." + $gcn)
  $Out -> Add("peek global.arg_counter")
  $Out -> Add("pop")
  $gcn++

  for gv in $Sem -> global_vars -> items:
    $Out -> Add("@" + gv)
  end
end

func GeneratorSVM::GenMethodHeader(m):
  mname ?= ""
  if m -> is_class_method:
    mname += m -> class_name + "__"
  end

  mname += m -> method_name

  $Out -> Add("pushcp " + mname + "__end")
  $Out -> Add("jp")
  $Out -> Add(mname + ":")

  for v in m -> varlist -> items:
    $Out -> Add("@" + mname + "." + v)
  end

  pcnt ?= 0
  err ?= false
  for p in m -> params -> items:
    if err:
      raise new Exception("Invalid method '" + mname + "' declaration at line " +
                          (m -> line + 1) + " at file '" + m -> fp + "'.")
    end

    switch p -> type:
      case MashASTP_SimpleObject:
        $Out -> Add("peek " + mname + "." + p -> Obj -> Value)
        $Out -> Add("pop")
        pcnt++
      end

      case MashASTP_SpecRectObject:
        $Out -> Add("word generator.const.gcn." + $gcn + " " + pcnt)
        $Out -> Add("pushcp generator.const.gcn." + $gcn)
        $Out -> Add("push global.arg_counter")
        $Out -> Add("sub")
        $Out -> Add("pushcp system_op_argsarr")
        $Out -> Add("jc")
        $Out -> Add("peek " + mname + "." + p -> Obj -> Value)
        $Out -> Add("pop")
        err = true
        $gcn++
      end
    end
  end

  return mname
end

proc GeneratorSVM::GenMethodEnd(m, mname):
  $Out -> Add("jr")
  $Out -> Add(mname + "__end:")
end

/*
 *  Generating code (main loop's)
 */
proc GeneratorSVM::ProcessNext(node, vars, mname):
  $NextNode(node, vars, mname)

  whilst ($LazyGen -> Count() > 0) | ($LazyGenSwap -> Count() > 0):
    if $LazyGen -> Count() > 0:
      n ?= $LazyGen -> get(0)
      $LazyGen -> delete(0)

      for i back $LazyGen -> Items:
        $LazyGenSwap -> Insert(i, 0)
      end
      $LazyGen -> Clear()

      $NextNode(n, vars, mname)
    else:
      if $LazyGenSwap -> Count() > 0:
        n ?= $LazyGenSwap -> get(0)
        $LazyGenSwap -> delete(0)
        $NextNode(n, vars, mname)
      end
    end

    gc()
  end
end



/*
 *  Generating code for constructions & expressions
 */
func GeneratorSVM::LastExprFlag():
  if $ExprBeginnings -> Size() > 0:
    return $ExprBeginnings -> peek_back()
  else:
    return false
  end
end

proc GeneratorSVM::LastExprFlagChange():
  if $ExprBeginnings -> Size() > 0:
    $ExprBeginnings -> pop_back()
    $ExprBeginnings -> push_back(false)
  end
end

proc GeneratorSVM::NextNode(node, vars, mname):
  switch node -> type:
    case ExprFalse:
      $LastExprFlagChange()
    end

    case ExprNew:
      $ExprBeginnings -> push_back(true)
    end

    case ExprEnd:
      if $ExprBeginnings -> Size() > 0:
        $ExprBeginnings -> pop_back()
      end
    end

    case PreGenerated:
      $Out -> Add(node -> code)
    end

    case PreGeneratedSet:
      for pg in node -> items:
        $Out -> Add(pg -> code)
      end
    end

    case MashASTB_Inline:
      $Out -> Add(node -> val)
    end

    case MashASTE_Operation:
      if node -> Op -> Op -> value == "new":
        println("New...")
      else:
        $LazyGen -> Add(node -> A)
        $LazyGen -> Add($GenOperation(node -> Op -> Op -> value, false))
      end
    end

    case MashASTE_OperationLR:
      if node -> Op -> Op -> value == "?=":
        switch node -> L -> type:
          case MashASTP_SimpleObject:
            if (node -> L -> Obj -> info == ttWord) &
               ($Sem -> global_vars -> IndexOf(node -> L -> Obj -> value) <> null):

              if node -> R -> type == MashASTE_OperationLR:
                $LazyGen -> Add(new ExprNew)
                $LazyGen -> Add(node -> R)
                $LazyGen -> Add(new ExprEnd)
              else:
                $LazyGen -> Add(new ExprFalse)
                $LazyGen -> Add(node -> R)
              end

              $LazyGen -> Add(new PreGenerated("peek " + node -> L -> Obj -> value))
              $LazyGen -> Add(new PreGenerated("pop"))
            else:
              raise new Exception("Invalid assigment for " + node -> L -> Obj -> value)
            end
          end

          case MashASTP_IndexedObject:
            $LazyGen -> Add(node -> R)
            $LazyGen -> Add(new ExprFalse)
            $GenArrayOp(node -> L -> Obj, node -> L -> Indexes -> Objects, "peekai")
          end
        end
      else:
        if ~(node -> Op -> Op -> value in ["+", "-", "/", "*",
                                           "\", "%", "&", "|",
                                           "^", "<<", ">>"]):
          $LazyGen -> Add(new ExprFalse)
        end

        $LazyGen -> Add(node -> R)
        $LazyGen -> Add(node -> L)
        $LazyGen -> Add($GenOperation(node -> Op -> Op -> value, true))
      end
    end

    case MashASTP_SimpleObject:
      switch node -> Obj -> info:
        case ttDigit:
          if "." in node -> Obj -> value:
            $Out -> add("real generator.const.gcn." + $gcn + " " +  node -> Obj -> value)
            $Out -> add("pushc generator.const.gcn." + $gcn)
            $gcn++
          else:
            $Out -> add("word generator.const.gcn." + $gcn + " " + node -> Obj -> value)
            $Out -> add("pushc generator.const.gcn." + $gcn)
            $gcn++
          end
        end

        case ttString:
          $Out -> add("str generator.const.gcn." + $gcn + " " + DQuote +
                      node -> Obj -> value + DQuote)
          $Out -> add("pushc generator.const.gcn." + $gcn)
          $gcn++
        end

        case ttWord:
          if ($Sem -> const_names -> IndexOf(node -> Obj -> value) <> null) |
             ($Sem -> methods_names -> IndexOf(node -> Obj -> value) <> null) |
             ($Sem -> imp_names -> IndexOf(node -> Obj -> value) <> null):
            $Out -> add("pushc " + node -> Obj -> value)
          else:
            vname ?= node -> Obj -> value

            if vars <> null:
              if vars -> IndexOf(vname) <> null:
                vname = mname + "." + vname
              end
            end

            $Out -> add("push " + vname)

            if $LastExprFlag():
              $Out -> add("copy")
              $Out -> add("swp")
              $Out -> add("pop")
              $LastExprFlagChange()
            end
          end
        end
      end
    end

    case MashASTP_ObjectByRef:
    end

    case MashASTP_IndexedObject:
      if node -> Obj -> Obj -> value == "new":
        $GenArrayAlloc(node -> Indexes -> Objects)
      else:
        $GenArrayOp(node -> Obj, node -> Indexes -> Objects, "pushai")

        if $LastExprFlag():
          $LazyGenCode("copy")
          $LazyGenCode("swp")
          $LazyGenCode("pop")
          $LazyGen -> Add(new ExprFalse)
        end
      end
    end

    case MashASTP_Call:
      isInvoke ?= false
      for inv in $Sem -> imp_names -> items:
        if node -> Obj -> Obj -> value == inv:
          isInvoke = true
          break
        end
      end

      for arg back node -> args -> objects -> items:
        $LazyGen -> Add(arg)
      end

      $LazyGen -> Add(node -> Obj)
      if isInvoke:
        $LazyGenCode("invoke")
      else:
        $LazyGenCode("word generator.const.gcn." + $gcn + " " +
                     node -> args -> objects -> count())
        $LazyGenCode("pushcp generator.const.gcn." + $gcn)
        $LazyGenCode("push global.arg_counter")
        $LazyGenCode("mov")
        $gcn++
        $LazyGenCode("jc")
      end
    end

    case MashASTP_Enum:
      l ?= node -> Objects -> Count()
      $LazyGenCode("word generator.const.gcn." + $gcn + " " + l)
      $LazyGenCode("pushcp generator.const.gcn." + $gcn)
      $gcn++

      $LazyGenCode("word generator.const.gcn." + $gcn + " 1")
      $LazyGenCode("pushcp generator.const.gcn." + $gcn)
      $gcn++
      $LazyGenCode("newa")

      ind ?= 0
      for n in node -> Objects -> items:
        $LazyGenCode("pcopy")
        $LazyGen -> Add(n)
        $LazyGenCode("swp")

        $LazyGenCode("word generator.const.gcn." + $gcn + " " + ind)
        $LazyGenCode("pushcp generator.const.gcn." + $gcn)
        $gcn++

        $LazyGenCode("swp")
        $LazyGenCode("peekai")

        ind++
      end
    end

    case MashExpressionAST:
      if node -> treeNode -> type <> MashASTE_OperationLR:
        $LazyGen -> Add(node -> treeNode)
      else:
        $LazyGen -> Add(new ExprNew)
        $LazyGen -> Add(node -> treeNode)
        $LazyGen -> Add(new ExprEnd)
      end
    end

    /*
     *  Constructions
     */
    case MashASTB_If:
      $LazyGenCode("pushcp generator.if.gcn." + $gcn + ".else")
      $LazyGen -> Add(node -> Expr)
      $LazyGenCode("jz")
      $LazyGenCode("pop")

      for n in node -> nodes -> items:
        $LazyGen -> Add(n)
      end

      if node -> hasElse:
        $LazyGenCode("pushcp generator.if.gcn." + $gcn + ".end")
        $LazyGenCode("jp")
        $LazyGenCode("generator.if.gcn." + $gcn + ".else:")
        for n in node -> nodesElse -> items:
          $LazyGen -> Add(n)
        end
        $LazyGenCode("generator.if.gcn." + $gcn + ".end:")
      else:
        $LazyGenCode("generator.if.gcn." + $gcn + ".else:")
      end
      $gcn++
    end

    case MashASTB_While:
      $LazyGenCode("generator.while.gcn." + $gcn + ".start:")
      $LazyGenCode("pushcp generator.while.gcn." + $gcn + ".end")
      $LazyGen -> Add(node -> Expr)
      $LazyGenCode("jz")
      $LazyGenCode("pop")

      for n in node -> nodes -> items:
        $LazyGen -> Add(n)
      end

      $LazyGenCode("pushcp generator.while.gcn." + $gcn + ".start")
      $LazyGenCode("jp")
      $LazyGenCode("generator.while.gcn." + $gcn + ".end:")

      $gcn++
    end

    case MashASTB_Method:
      for n in node -> nodes -> items:
        $LazyGen -> Add(n)
      end
    end
  end
end

/*
 *  Some methods
 */

proc GeneratorSVM::GenArrayOp(obj, indexes, targetOp):
  $LazyGen -> Add(obj)

  cnt ?= indexes -> count()
  i ?= 0
  while i < cnt:
    $LazyGen -> Add(indexes -> get(i))
    $LazyGenCode("swp")
    i++

    if i < cnt:
      $LazyGenCode("pushai")
    else:
      $LazyGenCode(targetOp)
    end
  end
end

proc GeneratorSVM::GenArrayAlloc(indexes):
  for x back indexes -> items:
    $LazyGen -> Add(x)
  end

  $LazyGenCode("word generator.const.gcn." + $gcn + " " + indexes -> count())
  $LazyGenCode("pushcp generator.const.gcn." + $gcn)
  $gcn++

  $LazyGenCode("newa")
end

/*
 *  Generating operations for expressions
 */

func GeneratorSVM::GenOperation(op, isLR):
  switch op:
    case "+":
      r ?= new PreGeneratedSet()
      r -> Next("add")
      return r
    end

    case "-":
      r ?= new PreGeneratedSet()

      if isLR:
        r -> Next("sub")
      else:
        r -> Next("neg")
      end

      return r
    end

    case "*":
      r ?= new PreGeneratedSet()
      r -> Next("mul")
      return r
    end

    case "/":
      r ?= new PreGeneratedSet()
      r -> Next("div")
      return r
    end

    case "\":
      r ?= new PreGeneratedSet()
      r -> Next("idiv")
      return r
    end

    case "%":
      r ?= new PreGeneratedSet()
      r -> Next("mod")
      return r
    end

    case "&":
      r ?= new PreGeneratedSet()
      r -> Next("and")
      return r
    end

    case "|":
      r ?= new PreGeneratedSet()
      r -> Next("or")
      return r
    end

    case "^":
      r ?= new PreGeneratedSet()
      r -> Next("xor")
      return r
    end

    case "<<":
      r ?= new PreGeneratedSet()
      r -> Next("shl")
      return r
    end

    case ">>":
      r ?= new PreGeneratedSet()
      r -> Next("shr")
      return r
    end

    case ">":
      r ?= new PreGeneratedSet()
      r -> Next("bg")
      return r
    end

    case ">=":
      r ?= new PreGeneratedSet()
      r -> Next("be")
      return r
    end

    case "==":
      r ?= new PreGeneratedSet()
      r -> Next("eq")
      return r
    end

    case "<":
      r ?= new PreGeneratedSet()
      r -> Next("swp")
      r -> Next("bg")
      return r
    end

    case "<=":
      r ?= new PreGeneratedSet()
      r -> Next("swp")
      r -> Next("bg")
      return r
    end

    case "in":
      r ?= new PreGeneratedSet()
      r -> Next("pushcp system_op_in")
      r -> Next("jc")
      return r
    end

    case "..":
      r ?= new PreGeneratedSet()
      r -> Next("pushcp system_op_range")
      r -> Next("jc")
      return r
    end

    case "+=":
      r ?= new PreGeneratedSet()
      r -> Next("add")
      r -> Next("pop")
      return r
    end

    case "-=":
      r ?= new PreGeneratedSet()
      r -> Next("sub")
      r -> Next("pop")
      return r
    end

    case "*=":
      r ?= new PreGeneratedSet()
      r -> Next("mul")
      r -> Next("pop")
      return r
    end

    case "/=":
      r ?= new PreGeneratedSet()
      r -> Next("div")
      r -> Next("pop")
      return r
    end

    case "\=":
      r ?= new PreGeneratedSet()
      r -> Next("idiv")
      r -> Next("pop")
      return r
    end

    case "%=":
      r ?= new PreGeneratedSet()
      r -> Next("mod")
      r -> Next("pop")
      return r
    end

    case "&=":
      r ?= new PreGeneratedSet()
      r -> Next("and")
      r -> Next("pop")
      return r
    end

    case "|=":
      r ?= new PreGeneratedSet()
      r -> Next("or")
      r -> Next("pop")
      return r
    end

    case "^=":
      r ?= new PreGeneratedSet()
      r -> Next("xor")
      r -> Next("pop")
      return r
    end

    case "<<=":
      r ?= new PreGeneratedSet()
      r -> Next("shl")
      r -> Next("pop")
      return r
    end

    case ">>=":
      r ?= new PreGeneratedSet()
      r -> Next("shr")
      r -> Next("pop")
      return r
    end

    case "=":
      r ?= new PreGeneratedSet()
      r -> Next("mov")
      return r
    end

    case "@=":
      r ?= new PreGeneratedSet()
      r -> Next("mvbp")
      return r
    end

    case "~":
      r ?= new PreGeneratedSet()
      r -> Next("not")
      return r
    end

    case "++":
      r ?= new PreGeneratedSet()
      r -> Next("inc")
      r -> Next("pop")
      return r
    end

    case "--":
      r ?= new PreGeneratedSet()
      r -> Next("dec")
      r -> Next("pop")
      return r
    end

    case "@":
      r ?= new PreGeneratedSet()
      r -> Next("new")
      r -> Next("peek global.temp")
      r -> Next("movp")
      r -> Next("push global.temp")
      return r
    end

    case "?":
      r ?= new PreGeneratedSet()
      r -> Next("gvbp")
      return r
    end
  end
end
