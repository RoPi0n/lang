uses <classes\vector>
uses <classes\list>
uses "ast\base\ast.mash"
uses "ast\blocks.mash"
uses "ast\expressions\blocks.mash"

class MashExpressionAST(MashBaseAST):
  protected:
    var stk,
        nodes,
        astvect

  public:
    proc Create,
         Process,
         MakeTree,

         NextPrimitive,
         NextBraces,
         NextRectBraces,
         MakeEnum
end

proc MashExpressionAST::Create(tokens, fp, vect):
  MashBaseAST::Create$(tokens, fp)

  $astvect ?= vect

  $stk ?= new list()
  $nodes ?= new list()
end

proc MashExpressionAST::Process():
  token_id ?= 0
  while token_id < $tokens -> count():
    prim ?= $NextPrimitive(token_id)
    token_id++

    if prim <> null:
      $nodes -> add(prim)

      /*switch prim -> type:
        case MashASTP_SimpleObject:
          println("simple object: ", prim -> obj -> value)
        end

        case MashASTP_ObjectByRef:
          p ?= new list()
          for t in prim -> objPath -> items:
            p -> add(t -> obj -> value)
          end
          println("object by ref: ", p -> items)
        end

        case MashASTP_Call:
          println("call...")
        end

        case MashASTP_Operator:
          println("operator: ", prim -> op -> value)
        end
      end*/
    end

    gc()
  end

  $MakeTree()
end

proc MashExpressionAST::MakeTree():
  //
end

func MashExpressionAST::NextPrimitive(token_id):
  token ?= $token(token_id)
  $lastTk ?= token

  if token -> info in [ttDigit, ttString, ttWord]:
    Obj ?= null

    MashExpressionAST_NextPrimitive_Lp:

    if ($TkCheck($token(token_id + 1)) == "->") & (token -> info == ttWord):
      if Obj == null:
        Obj ?= new MashASTP_ObjectByRef()
        Obj -> ObjPath -> Add(token)
      else:
        NewObj ?= new MashASTP_ObjectByRef()
        NewObj -> ObjPath -> Add(Obj)
        Obj ?= NewObj
      end

      while ($TkCheck($token(token_id + 1)) == "->") &
            ($TkCheckType($token(token_id + 2)) == ttWord):
        token_id += 2
        Obj -> ObjPath -> Add( new MashASTP_SimpleObject($token(token_id)) )
      end

      tk ?= $token(token_id + 1)
      if $TkCheck(tk) == "->":
        raise new Exception("Invalid token after -> at line " + (tk -> line + 1) +
                            " at file '" + $fp + "'")
      end
    end

    if Obj == null:
      Obj ?= new MashASTP_SimpleObject(token)
    end

    if $TkCheck($token(token_id + 1)) == "(":
      token_id++
      ArgsBraces ?= $NextBraces(token_id)
      ArgsEnum ?= $MakeEnum(ArgsBraces)

      ObjCall ?= new MashASTP_Call(Obj, ArgsEnum)
      Obj ?= ObjCall
    end

    if $TkCheck($token(token_id + 1)) == "[":
      token_id++
      IndexesEnum ?= new MashASTP_Enum()

      while true:
        NextRBraces ?= $NextRectBraces(token_id)
        Index ?= new MashExpressionAST(NextRBraces, $fp, $astvect)
        $astvect -> push_back(Index)
        IndexesEnum -> Objects -> Add(Index)

        if $TkCheck($token(token_id + 1)) == "[":
          token_id++
        else:
          break
        end
      end

      ObjIndexed ?= new MashASTP_IndexedObject(Obj, IndexesEnum)
      Obj ?= ObjIndexed
    end

    if $TkCheck($token(token_id + 1)) in ["->", "(", "["]:
      jump MashExpressionAST_NextPrimitive_Lp
    end

    return Obj
  else:
    // Check for operators
    if token -> info == ttToken:
      switch token -> value:
        case "(":
          ExprTokens ?= $NextBraces(token_id)
          Expr ?= new MashExpressionAST(ExprTokens, $fp, $astvect)
          //Expr -> Process()

          for tk in Expr -> tokens -> items:
            println(tk -> value)
          end

          $astvect -> push_back(Expr)

          return Expr
        end

        case "[":
          return $MakeEnum($NextRectBraces(token_id))
        end

        else:
          return new MashASTP_Operator(token)
      end
    end
  end
end


func MashExpressionAST::NextBraces(token_id):
  brace_cnt ?= 1
  SubExpr ?= new list()

  while brace_cnt > 0:
    token_id++
    tk ?= $token(token_id)

    if tk == null:
      raise new Exception("Unclosed '(' at line " + (token -> line + 1) +
                          " at file '" + $fp + "'")
    end

    switch tk -> value:
      case "(":
        brace_cnt++
      end

      case ")":
        brace_cnt--
      end
    end

    if brace_cnt > 0:
      SubExpr -> add(tk)
    end
  end

  return SubExpr
end

func MashExpressionAST::NextRectBraces(token_id):
  brace_cnt ?= 1
  SubExpr ?= new list()

  while brace_cnt > 0:
    token_id++
    tk ?= $token(token_id)

    if tk == null:
      raise new Exception("Unclosed '[' at line " + (token -> line + 1) +
                          " at file '" + $fp + "'")
    end

    switch tk -> value:
      case "[":
        brace_cnt++
      end

      case "]":
        brace_cnt--
      end
    end

    if brace_cnt > 0:
      SubExpr -> add(tk)
    end
  end

  return SubExpr
end


func MashExpressionAST::MakeEnum(tokens):
  Res ?= new MashASTP_Enum()
  Expr ?= new list()

  br_cnt ?= 0
  rbr_cnt ?= 0

  for tk in tokens -> items:
    switch tk -> value:
      case "(":
        br_cnt++
        Expr -> add(tk)
      end

      case ")":
        br_cnt--
        Expr -> add(tk)
      end

      case "[":
        rbr_cnt++
        Expr -> add(tk)
      end

      case "]":
        br_cnt--
        Expr -> add(tk)
      end

      case ",":
        if (br_cnt == 0) & (rbr_cnt == 0):
          Itm ?= new MashExpressionAST(Expr, $fp, $astvect)
          $astvect -> push_back(Itm)
          Res -> Objects -> add(Itm)
          Expr ?= new list()
        else:
          Expr -> add(tk)
        end
      end

      else:
        Expr -> add(tk)
    end
  end

  if Expr -> count() > 0:
    Itm ?= new MashExpressionAST(Expr, $fp, $astvect)
    $astvect -> push_back(Itm)
    Res -> Objects -> add(Itm)
  end

  return Res
end






