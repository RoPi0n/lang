// Base functions & Initialization.

import _I2S         "bf.lib" "INTTOSTR"
import _F2S         "bf.lib" "FLOATTOSTR"
import _S2I         "bf.lib" "STRTOINT"
import _S2F         "bf.lib" "STRTOFLOAT"
import Halt         "bf.lib" "HALT"
import Sleep        "bf.lib" "SLEEP"
import _StrUpper    "bf.lib" "STRUPPER"
import _StrLower    "bf.lib" "STRLOWER"
import _Now         "bf.lib" "CURRENTDATETIME"
import Randomize    "bf.lib" "RANDOMIZE"
import _Random      "bf.lib" "RANDOM"
import _RandomB     "bf.lib" "RANDOMB"
import _TickCnt     "bf.lib" "TICKCNT"

// Global values
int  true  -1
int  false  0

proc __GetVM_Null():
  pushn
end

var null = __GetVM_Null()

proc IsNull(object_pointer):
  push object_pointer
  push null
  peq
  gpm
end

func b2s(boolean_value):
  if boolean_value == true:
    return "true"
  else:
    return "false"
  end
end

proc ExitThread():
  threxit
end

func new(object_pointer):
  v ?= new
  v = object_pointer
  return v
end

proc copy(object_pointer):
  push object_pointer
  copy
  gpm
  swp
  pop
end

func gpmx(object_pointer):
  push object_pointer
  gpm
  pop
  return object_pointer
end

enum Types [TypeNull, TypeWord, TypeInt, TypeReal, TypeStr, TypeArray, TypeClass]
word TypePtr 255

proc TypeOf(object_pointer):
  push object_pointer
  typeof
  gpm
end

proc SizeOf(object_pointer):
  push object_pointer
  sizeof
  gpm
end

func Len(array_pointer):
  push array_pointer
  alen
  gpm
  var ln
  pop ln
  return ln
end

proc SetLen(array_pointer, new_length):
  push array_pointer
  push new_length
  salen
  pop
end

proc Fill(array_pointer, value):
  l ?= len(array_pointer)
  for(i ?= 0; i < l; i++):
    array_pointer[i] ?= copy(value)
  end
end

func _op_range(value_from, value_to):
  if value_from > value_to:
    r ?= new[value_from - value_to + 1]
    for(i ?= copy(value_from); i >= value_to; i--):
      r[value_from - i] ?= copy(i)
    end
  else:
    r ?= new[value_to - value_from + 1]
    for(i ?= copy(value_from); i <= value_to; i++):
      r[i - value_from] ?= copy(i)
    end
  end
  return gpmx(r)
end

proc gc():
  gc
  stkdrop
end

{_ifndef_ argcounter}

proc Free(obj):
  rem obj
end

{_end_}

{_ifdef_ argcounter}

proc Free([objects]):
  for t in objects:
    rem t
  end
end

{_end_}

func _op_in(v, array):
  i ?= 0
  ln ?= len(array)
  while i < ln:
    if array[i] == v:
      return true
    end
    inc i
  end
  return false
end

func ptr(a):
  return @a
end

func temp():
  return 0
end

func if(boolean_value, value_on_true, value_on_false):
  if boolean_value:
    return value_on_true
  else:
    return value_on_false
  end
end

var ParamCount, ParamList

proc __EntryPoint():
  pop ParamCount
  ParamList ?= new[ParamCount]

  i ?= 0
  while i < ParamCount:
    peek ParamList[i]
    i++
  end

  Main()
  gc()
end

proc gpm(value_pointer):
  push value_pointer
  gpm
  pop
end

func __PopRest(args_count):
  t ?= 0
  args ?= gpmx(new[args_count])
  while t < args_count:
    peek args[t]
    inc t
  end
  return args
end

// API redefine

proc I2S():
  _I2S()
  gpm
end

proc F2S():
  _F2S()
  gpm
end

proc S2I():
  _S2I()
  gpm
end

proc S2F():
  _S2F()
  gpm
end

proc StrUpper():
  _StrUpper()
  gpm
end

proc StrLower():
  _StrLower()
  gpm
end

proc Now():
  _Now()
  gpm
end

proc Random():
  _Random()
  gpm
end

proc RandomB():
  _RandomB()
  gpm
end

proc TickCnt():
  _TickCnt()
  gpm
end

proc vcall(method_pointer):
  argcount--
  call method_pointer
end

func max([args]):
  if len(args) > 0:
    r ?= args[0]
    for x in args:
      r = if(x > r, x, r)
    end
    return r
  else:
    return null
  end
end

func min([args]):
  if len(args) > 0:
    r ?= args[0]
    for x in args:
      r = if(x < r, x, r)
    end
    return r
  else:
    return null
  end
end

// Something

var LnBreak = new(_Chr(13) + _Chr(10))

// Base functions

proc Ord(char):
  push char
  chord
  gpm
end


proc _Chr(wrd):
  push wrd
  ordch
  gpm
end

func Chr([chars]):
  r ?= ""
  for(i ?= 0; i < len(chars); i++):
    r += _Chr(chars[i])
  end
  return r
end
