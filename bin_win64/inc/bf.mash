// Base functions & Initialization.

uses <Exceptions>

import I2S              "bf.lib" "INTTOSTR"
import F2S              "bf.lib" "FLOATTOSTR"
import S2I              "bf.lib" "STRTOINT"
import S2F              "bf.lib" "STRTOFLOAT"
import Halt             "bf.lib" "HALT"
import Sleep            "bf.lib" "SLEEP"
import StrUpper         "bf.lib" "STRUPPER"
import StrLower         "bf.lib" "STRLOWER"
import Now              "bf.lib" "CURRENTDATETIME"
import Randomize        "bf.lib" "RANDOMIZE"
import Random           "bf.lib" "RANDOM"
import RandomTo         "bf.lib" "RANDOMB"
import TickCnt          "bf.lib" "TICKCNT"
import GetSystemSlash   "bf.lib" "GETSYSTEMSLASH"

int  true  -1
int  false  0

proc __GetVM_Null():
  pushn
end

var null = __GetVM_Null(),
    sysslash = GetSystemSlash()

func b2s(boolean_value):
  if boolean_value == true:
    return "true"
  else:
    return "false"
  end
end

proc ExitThread():
  threxit
end

func new(object_pointer):
  v ?= new
  v = object_pointer
  return v
end

proc copy(object_pointer):
  push object_pointer
  copy
  swp
  pop
end

enum Types [TypeNull, TypeWord, TypeInt, TypeReal, TypeStr, TypeArray, TypeClass, TypeRef]
word TypePtr 255

proc TypeOf(object_pointer):
  push object_pointer
  typeof
end

proc SizeOf(object_pointer):
  push object_pointer
  sizeof
end

proc Len(array_pointer):
  push array_pointer
  alen
end

proc SetLen(array_pointer, new_length):
  push array_pointer
  push new_length
  salen
  pop
end

proc Fill(array_pointer, value):
  l ?= len(array_pointer)
  for(i ?= 0; i < l; i++):
    array_pointer[i] ?= copy(value)
  end
end

func _op_range(value_from, value_to):
  if value_from > value_to:
    r ?= new[value_from - value_to + 1]
    for(i ?= copy(value_from); i >= value_to; i--):
      r[value_from - i] ?= copy(i)
    end
  else:
    r ?= new[value_to - value_from + 1]
    for(i ?= copy(value_from); i <= value_to; i++):
      r[i - value_from] ?= copy(i)
    end
  end
  return r
end

proc gc():
  stkdrop
  gc
end

func _op_in(v, array):
  i ?= 0
  ln ?= len(array)
  while i < ln:
    if array[i] == v:
      return true
    end
    i++
  end
  return false
end

func ptr(a):
  return @a
end

func if(boolean_value, value_on_true, value_on_false):
  if boolean_value:
    return value_on_true
  else:
    return value_on_false
  end
end

func __PopRest(args_count):
  t ?= 0
  args ?= new[args_count]
  while t < args_count:
    peek args[t]
    t++
  end
  return args
end

proc vcall(method_pointer):
  argcount--
  call method_pointer
end

func max([args]):
  if len(args) > 0:
    r ?= args[0]
    for x in args:
      r = if(x > r, x, r)
    end
    return r
  else:
    return null
  end
end

func min([args]):
  if len(args) > 0:
    r ?= args[0]
    for x in args:
      r = if(x < r, x, r)
    end
    return r
  else:
    return null
  end
end

var LnBreak = Chr(13, 10)

proc Ord(char):
  push char
  chord
end

proc _Chr(wrd):
  push wrd
  ordch
end

func Chr([chars]):
  r ?= ""
  for(i ?= 0; i < len(chars); i++):
    r += _Chr(chars[i])
  end
  return r
end

////////////////////////////////////////////////////////////////////////////////
// Entry point
////////////////////////////////////////////////////////////////////////////////

var ParamCount, ParamList

proc __EntryPoint():
  pop ParamCount
  ParamList ?= new[ParamCount]

  i ?= 0
  while i < ParamCount:
    peek ParamList[i]
    i++
  end

  Main()
  gc()
end
